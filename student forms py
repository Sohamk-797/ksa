from django import forms
from django.contrib.auth.models import User
from django.core.exceptions import ValidationError
from django.contrib.auth.password_validation import validate_password
import re
from . import models
from exam import models as QMODEL

class StudentUserForm(forms.ModelForm):
    confirm_password = forms.CharField(widget=forms.PasswordInput(), label='Confirm Password')
    class Meta:
        model=User
        fields=['first_name','last_name','username','password']
        widgets = {
        'password': forms.PasswordInput()
        }
    
    def clean(self):
        cleaned_data = super().clean()
        # Unique username validation for create
        username = cleaned_data.get('username')
        if username and User.objects.filter(username=username).exists():
            self.add_error('username', 'This username is already taken. Please choose another.')
        password = cleaned_data.get('password')
        confirm_password = cleaned_data.get('confirm_password')
        if password and confirm_password and password != confirm_password:
            self.add_error('confirm_password', 'Passwords do not match.')
        # Run Django's configured password validators (min length, common, not numeric)
        if password:
            try:
                validate_password(password)
            except ValidationError as ve:
                for msg in ve.messages:
                    self.add_error('password', msg)
            # Custom rule: must include at least one symbol
            if not re.search(r"[^A-Za-z0-9]", password):
                self.add_error('password', 'Password must include at least one symbol (e.g., ! @ # $ %).')
        return cleaned_data

class StudentForm(forms.ModelForm):
    class Meta:
        model=models.Student
        fields=['address','mobile','batch']


class StudentUserUpdateForm(forms.ModelForm):
    # Optional password field (not required); only change if provided
    password = forms.CharField(
        widget=forms.PasswordInput(),
        required=False,
        label='Password'
    )

    class Meta:
        model = User
        fields = ['first_name', 'last_name', 'username']  # exclude model password to avoid overwriting

    def clean(self):
        cleaned_data = super().clean()
        # Unique username validation for update (exclude self.instance)
        username = cleaned_data.get('username')
        if username:
            qs = User.objects.filter(username=username)
            if self.instance and self.instance.pk:
                qs = qs.exclude(pk=self.instance.pk)
            if qs.exists():
                self.add_error('username', 'This username is already taken. Please choose another.')
        pwd = cleaned_data.get('password')
        # Validate only if admin provided a new password
        if pwd:
            try:
                validate_password(pwd)
            except ValidationError as ve:
                for msg in ve.messages:
                    self.add_error('password', msg)
            if not re.search(r"[^A-Za-z0-9]", pwd):
                self.add_error('password', 'Password must include at least one symbol (e.g., ! @ # $ %).')
        return cleaned_data

